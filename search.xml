<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[锁的分类]]></title>
    <url>%2Fposts%2Funcategorized%2F2019-01-14-%E9%94%81%E7%9A%84%E5%88%86%E7%B1%BB.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[线程通信]]></title>
    <url>%2Fposts%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2F2019-01-14-%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1.html</url>
    <content type="text"><![CDATA[数据通信方式单工单工数据传输只支持数据在一个方向上传输；在同一时间只有一方能接受或发送信息，不能实现双向通信，举例：电视，广播. 半双工半双工数据传输允许数据在两个方向上传输,但是,在某一时刻,只允许数据在一个方向上传输,它实际上是一种切换方向的单工通信；在同一时间只可以有一方接受或发送信息，可以实现双向通信。举例：对讲机。 全双工全双工数据通信允许数据同时在两个方向上传输,因此,全双工通信是两个单工通信方式的结合,它要求发送设备和接收设备都有独立的接收和发送能力；在同一时间可以同时接受和发送信息，实现双向通信，举例：电话通信 进程通信方式管道（pipe）管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有血缘关系的进程间使用。进程的血缘关系通常指父子进程关系。管道分为pipe（无名管道）和fifo（命名管道）两种，有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间通信。 信号量信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它通常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。 消息队列(message queue)消息队列是由消息组成的链表，存放在内核中 并由消息队列标识符标识。消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。消息队列与管道通信相比，其优势是对每个消息指定特定的消息类型，接收的时候不需要按照队列次序，而是可以根据自定义条件接收特定类型的消息。 信号（signal）信号是一种比较复杂的通信方式，用于通知接收进程某一事件已经发生。 共享内存(shard memory)共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问，共享内存是最快的IPC方式，它是针对其他进程间的通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量配合使用，来实现进程间的同步和通信。 套接字(socket)套接口也是一种进程间的通信机制，与其他通信机制不同的是它可以用于不同系统及其网络之间的进程通信。 线程通信锁机制 互斥锁：提供了以排它方式阻止数据结构被并发修改的方法。 读写锁：允许多个线程同时读共享数据，而对写操作互斥。 条件变量：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。 信号量机制包括无名线程信号量与有名线程信号量 无名线程信号量 有名线程信号量 信号机制类似于进程间的信号处理。 线程间通信的主要目的是用于线程同步，所以线程没有象进程通信中用于数据交换的通信机制。 ###]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>线程</tag>
        <tag>java</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客链接]]></title>
    <url>%2Fposts%2F%E9%9D%A2%E8%AF%95%2F2019-01-13-%E5%8D%9A%E5%AE%A2%E9%93%BE%E6%8E%A5.html</url>
    <content type="text"><![CDATA[消息队列]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>队列</tag>
        <tag>面试</tag>
        <tag>MQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo文章简单加密访问]]></title>
    <url>%2Fposts%2F%E5%8D%9A%E5%AE%A2%2F2019-01-13-Hexo%E6%96%87%E7%AB%A0%E7%AE%80%E5%8D%95%E5%8A%A0%E5%AF%86%E8%AE%BF%E9%97%AE.html</url>
    <content type="text"><![CDATA[Hexo文章简单加密访问测试]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo相关]]></title>
    <url>%2Fposts%2Funcategorized%2F2019-01-11-hexo%E7%9B%B8%E5%85%B3.html</url>
    <content type="text"><![CDATA[hexo相关设置 Hexo操作常用命令1npm install hexo-deployer-git #此时当前分支应显示为hexo 阅读全文在文章合适的位置添加&lt;!-- more --&gt;，Hexo推荐使用。 换电脑之后的操作 hexo系列问题之我们换了电脑怎么办 拉取代码后操作如下命令,该命令会自动安装Hexo相关依赖。 1npm install hexo-deployer-git #此时当前分支应显示为hexo 给主题next添加搜索功能 安装插件 1npm install hexo-generator-searchdb --save 修改配置文件 路径：/blog/themes/next下的_config.yml文件，进行编辑 12local_search: enable: true 修改主题next的默认宽度打开编辑`themes\next\source\css\_schemes\Pisces\_layout.styl`，在底部添加如下代码： 12345678910111213141516171819202122232425262728293031323334// 以下为新增代码！！header&#123; width: 75% !important; &#125;header.post-header &#123; width: auto !important;&#125;.container .main-inner &#123; width: 75%; &#125;.content-wrap &#123; width: calc(100% - 260px); &#125;.header &#123; +tablet() &#123; width: auto !important; &#125; +mobile() &#123; width: auto !important; &#125;&#125;.container .main-inner &#123; +tablet() &#123; width: auto !important; &#125; +mobile() &#123; width: auto !important; &#125;&#125;.content-wrap &#123; +tablet() &#123; width: 100% !important; &#125; +mobile() &#123; width: 100% !important; &#125;&#125; 常见问题hexo的表体无法渲染Markdown语法​ 在##后面加空格,如 1## 二级标题 推荐next主题博客hoxios asdfv simon96 xiaweizi 参考链接 2018最新版Hexo博客Next主题6.0配置优化 hexo的next主题个性化教程：打造炫酷网站 Next主题个性化设置 Hexo设置主题以及Next主题个性设置 Hexo文章简单加密访问 最全Hexo博客搭建 来必力评论设置]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用命令]]></title>
    <url>%2Fposts%2Funcategorized%2F2019-01-11-Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html</url>
    <content type="text"><![CDATA[本文记录Linux常用命令 1、删除文件 1rm -rf * #删除所有文件，隐藏文件不会删除]]></content>
      <tags>
        <tag>命令</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git常用命令]]></title>
    <url>%2Fposts%2Funcategorized%2F2019-01-11-git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html</url>
    <content type="text"><![CDATA[1、拉取远程代码 12git clone https://github.com/ldjWillow/ldjWillow.github.io.gitgit clone -b hexo https://github.com/yourname/ldjWillow.github.io.git 从分支 hexo上拉取代码 2、查看分分支 123git branch 查看本地分支git branch -r 查看远程分支git branch -a 查看所有分支(本地和远程) 3、创建分支 12git branch node0 创建一个名为node0的分支git push origin node0 创建远程分支（实际上把本地分支node0推送到远程，故node0分支必须在本地先创建） 4、切换分支 1git checkout node0 5、创建并切换分支 1git checkout -b node1 6、删除分支 12git branch -d node1 删除本地分支git push origin --delete node0 删除远程分支 7、拉取分支git pull 1234$ git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;$ git pull origin next:master 如果远程分支(next)要与当前分支合并，则冒号后面的部分可以省略。上面命令可以简写为： $ git pull origin next 8、放弃本地修改，强制更新 git fetch 只是下载远程的库的内容，不做任何的合并 git reset 把HEAD指向刚刚下载的最新的版本 12git fetch --allgit reset --hard origin/master 9、本地关联远程分支 12git branch --set-upstream-to=origin/remote_branch your_branchgit push --set-upstream origin hexo 10、添加(git add) git add all和git add .区别 git add -A 和 git add . 的区别 123git add readme.txt 提交单个文件git add readme.txt ant.txt 提交多个文件，用空格隔开git add *.html 提交所有html文件]]></content>
  </entry>
</search>
